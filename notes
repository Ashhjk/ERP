________ERP________

ERP (Enterprise Resource Planning) is a type of software used by organizations to manage and integrate their core business processes. It provides a centralized system to collect, store, and manage data across various functions of an organization, ensuring streamlined workflows and improved efficiency.
Common Modules in ERP:

    Finance and Accounting: Tracks income, expenses, and financial reporting.
    Human Resources (HR): Manages employee data, payroll, and recruitment.
    Supply Chain Management: Oversees procurement, inventory, and logistics.
    Customer Relationship Management (CRM): Helps manage customer data and improve interactions.
    Manufacturing: Tracks production schedules and quality control.
    Sales and Marketing: Monitors sales pipelines and marketing campaigns
eg of ERP:
1.SAP
2.Microsoft
3.Infor

SAP is an erp produced by the company SAP.

________ABAP(Advanced Business Application Programming)_______
*its a high level programming language created by sap which help companies in customising the sap erp.
*Abap allows companies in customising the workflow ofvarious sap modules like financial accounting ,asset management, material management etc.
*it was developed by sap for writing sap applications 
*sap aaplications like S/4HANA ,ECC,Crm etc are created using the ABAP programming language.
*But some of the sap applications like SuccessFactors,Ariba,Concur,FieldGlass ,BTP etc are cloud SAPs..means they are not written using the ABAP..instead they are written using java , nodejs etc

____________________SAP ABAP PLATFORM FUNDAMENTALS__________________
**************different types of sap software applications****************
1.APPLICATION SOFTWARE
SAP ERP,SAP S/4 HANA : end to end application covering all the business processes
2.REPORTS AND ANALYTICS
tools that help in providing business analytics and reports
3.MOBILE ACCESS
eg: SAP FIORI they are the mobile applications so that the sap applications can be accessed anywhere
4.DBMS
eg:SAP HANA saps 
primary dbms is sap hana
5.CLOUD SOLUTIONS
Delivery of SAP solutions over the cloud, eliminating the need for on-premises infrastructure.
Includes SAP Business Technology Platform (BTP), SAP HANA Cloud, and SAP SuccessFactors.

*****SAP S/4HANA is next gen erp of sap...it allows the flow of information between various business f
unctions

******************HISTORY OF SAP's ERP***************
R2-> R3(business suite or ECC)-> Business Bydesign ->S/4 HANA

_____________SAP's 3 TIERED ARCHITECTURE______________
consist of three layers
1.presentation layer(web browser-sap fiori,business client,sap GUI)
2.Application layer
3.database layer (ABAP- SAP HANA database)

*Application and database layers can run on same hosts but possible only in case of smaller businesses ...for larger businesses both run on different hosts
     **********Database layer*********
SAP HANA database is used...while installing and running the sap application databases are created by default
*Application layer consist of numerous objects and logics
*presentation layer is available to the end user
_____________APPLICATION LAYER___________
ABAP platform is the application layer
*It includes various business processses like finance ,sales etc and also custom applications everything resides here
*Advanced Business Application Programming (ABAP) is the programming language that is used to build custom applications for the application layer
**********ABAP PLATFORM FUNCTIONS************
1.act as an application run time environment
2.act as a application development environment
3.used to build custom appplications
4.used for integration and data management platform
5.security platform
6.reporting platform

   ========> Application run time environment
act as the middle tier between the presentation and the databse layer
*ABAP based application are run on this platform
*it provides a secure platform
*application processing,troubleshooting and optimisation 

   ========> Application development environment
*helps to build responsive  applications using SAP UI5 for frontend and WebDinpro ABAP

   ========>Built in source management system
* custom code respository is there developed by sap...many developers can contribute to it at the same time and work on it simultaneously
*conflict resolution also ther like git 

   ========> Integration tools
*there are many integration tools  for ensuring coonrcativity btw different tools and applications 
*Remote Function Call Protocol(RFC) is one such integration tool...by using this functions can be  called in remote applications or even non sap systems
*Business Application Programming Interface(BAPI) connect between other external applications
*data integration converts the data from one form to another

   ========>Application security
using authentication to protect the application
   =========>Reports
get reports and analyses very easily
*ABAP LIST VIEWER(ALV) is one tool for creating aesthetic reports  in that we can sort and filter
*SAP crystal reports also a  tool supports advanced features like charting and advanced formulas

For each sap system there is a unique system id called SID.
Its alphanumeric
Start with uppercase
Only 3 letters

___________________SAP INSTANCE________________
we can think it as a work unit inside the sap system..they are doing specific jobs and services
*each sap instance run on a host..
*many instances can be run on the same host provided each of the instnaces should have unique SID and also a 2 digit instance number to uniquely identify the instance.
Types of Instances:

    Primary Application Server (PAS): The first instance created during installation. It’s the main worker for running the SAP system.
    Additional Application Server (AAS): Extra instances added to share the workload and handle more users or tasks.
    ABAP Central Services Instance (ASCS): A special instance that handles centralized services like communication and synchronization between other instances.

*Application layer consist of so many application instances and one instace for central services.
*the primary appllication server or instance is used at the time of installation
*every instance has a DISPATCHER
*each instance can be mapped to particular id
*dispatcher manages the processes and ensures workload is evenly distributed
*dispatcher checks the health of the processes and start or stop a process if necessaaary

______________WORK PROCESSES OF A DISPATCHER_________________
1. Dialog work process
whenever the user makes a request for some resources the dialog work process does this
*it executes the request ,get the data from the db and give it to the user
*manages the allocation of resources like memory and cpu so that multiple requests can be handled simultaneously

2.Batch work process
to perform background tasks 
*report generation
*non interactive process not interating with the users
*executes long running tasks
*helps in job scheduling so that the users can set to run the most important tasks first

3.Spool work process
*its used for printing
*when someone generates the spool request the request is stored in the database and then generate the output request for print devices

4. Update work process
*it manages an update queue
*when an sap process is completed it is the update request that updates the db

there are many application server instances in the application layer also there are centrak services etc

________________ABAP APPLICATION PROCESSING STEPS___________________

1. when a user logs on to the SAP system they the SAP GUI (user interface ) puts a request into the message server in the application layer.
2. then it looks for the application server with the most available resources.
3. on finding the  available application server the message server sends the message to the GUI to connect to the dispatcher of that particular server
4.then the connection from the message server is terminated and now connected to the application server
5.authentication request including the users credentials is passed to the AS
6. users request is put in wait queue
7. its managed in first in first out basis
8. when its right time the request is given to dialog work process of dispatcher because the users request is an interactive process
eg:suppose a user want to log in to the sap system then the task handler in the dispatcher sends checks the application program buffer for the data
and then load the data from the database and bring it to the dialog work process and store it in the memory
*if the user is login for the first time then his credentials wont be in the buffer...so they task handler looks for the data in the database and fulfills the request

_________________INTERNET COMMUNICATION MANAGER________________
INTERNET COMMUNICATION Manager assisgns the incoming https requests to the application server and the dispatcher based on looking the load and the schedule so that no application server is over;loaded
_________________SAP web dispatcher____________
What is the SAP Web Dispatcher?

    It’s like a traffic controller for web requests.
    When a user accesses an SAP system from a browser, the request first goes to the Web Dispatcher, which decides where to send it within the SAP environment.

What does it do?

    Gateway and Load Balancer:
        It acts as the single point of entry for all user requests.
        Balances the workload by distributing requests to different servers in the SAP system, ensuring none are overloaded.

    Security:
        It acts as a reverse proxy, meaning it hides the internal structure of the SAP systems from external users.
        Filters and modifies requests to ensure only valid ones are forwarded to SAP systems.

    Request Routing:
        Decides where to send each request based on rules, such as the host, port, or specific URL paths.

    Scalability:
        Handles large amounts of traffic and supports complex enterprise systems with multiple users and servers.

    Single Sign-On (SSO):
        Allows users to log in once and access multiple SAP systems without having to log in again for each one.

    Optimization:
        Handles tasks like SSL termination (encrypting and decrypting communication), caching data, and compressing content to improve speed.

How it Works:

    A user accesses an SAP application using a browser.
    The request is sent to the SAP Web Dispatcher.
    The Web Dispatcher:
        Checks rules to decide which back-end server should handle the request.
        Balances the load between servers to avoid overloading any single server.
        Sends the request to the chosen server for processing.
    The processed response is sent back to the user through the Web Dispatcher.
*Till now we have seen the user login request, now we can see how a transaction is processed..transaction means some kind of request from the user

______________________TRANSACTION PROCESSING____________________
1. processing a dialog request
2.definingan ABAP transaction
3.database interaction
4.Lock managemnet
5. update processing

 =====> Processing a dialogue request
Processing a Dialog Request in SAP

When a user interacts with an SAP application, the system follows a structured approach to handle their input and provide a response. Here’s a simplified explanation:
Key Concepts:

    Dialog Work Processes:
        These are the components on the application server that handle user requests.
        When a user performs an action (e.g., clicking a button or entering data), the dialog work process executes a corresponding dialog step.

    Dialog Steps:
        Each user action (e.g., clicking, submitting) is a dialog step, which involves processing logic, retrieving/manipulating data, and sending a response.
        These steps are small tasks, and multiple dialog steps can occur in a single transaction.
        Different dialog steps for the same user may be processed by different work processes. This is called work process multiplexing.

    Dynpros (Dynamic Programs):
        SAP screens are called dynpros, consisting of:
            Screen image: What the user sees.
            Flow logic: The rules defining how the screen behaves and interacts with data.

    PBO and PAI:
        Each screen follows two key stages:
            PBO (Process Before Output): Prepares the screen and its data before it’s displayed to the user.
            PAI (Process After Input): Processes user inputs after the user interacts with the screen.

How It Works:

    User Action:
    The user interacts with the system (e.g., enters data and clicks a button).

    Processing by the Dynpro Processor:
        The dynpro processor handles the screen logic and:
            Executes the PBO step to prepare the screen and data.
            Sends the screen to the user.

    User Interaction with Screen:
        The user interacts with the screen (e.g., entering values or pressing a button).
        The system triggers the PAI step, which processes the user input.

    ABAP Processor Execution:
        Based on the screen flow logic, the ABAP processor executes the required code or subprogram.
        If database access is needed, the database interface of the dialog work process handles it.

    Response to User:
        Once the processing is complete, a response is sent to the user (e.g., updated data or a new screen).

Example Scenario:

    A user opens a screen to update their contact information.
    The PBO step retrieves the current contact details and displays them on the screen.
    The user modifies their phone number and clicks “Save.”
    The PAI step processes the user input, validates the data, and updates the database.
    The system confirms the update and sends a success message back to the user.
________________Defining an SAP Transaction________________

An SAP transaction is typically made up of multiple dialog steps. These dialog steps, or processing units, are grouped together to generate a specific business result. For example, the creation of a financial document or a sales order. A transaction must satisfy the ACID test and is characterized by the following four attributes:

    Atomic: Atomic means that a transaction is either fully successful or does not have any effects at all. If a transaction-oriented system goes down, you need to ensure that inconsistent, partial results are not stored.
    Consistent: Consistent means that the system status changes from one that is accurate and consistent in business terms to another that is also accurate and consistent in business terms.
    Isolated: Isolated means that the changes made within a transaction can only be seen by other transactions, even those that run simultaneously, after the final confirmation (Commit).
    Durable: The results of a transaction are durable because after the final confirmation they are stored permanently in the database.

_____________ECLIPSE IDE____________
ABAP perspective
F1 - help about statement
F2- definition of statement
F3- definition of object

*we create development object in abap environment
*then on creation of these objects they are put under the package 
*this set of components is called repository object
*we first develop then test the components and later transport it to production after all these testing works


_______________Allowed in ABAP Class Names___________

    Letters (A-Z, a-z)
        Both uppercase and lowercase letters are allowed, but class names are case-insensitive in ABAP. Typically, uppercase is used by convention.

    Digits (0-9)
        Numbers can be included in the class name, but they cannot be the first character.

    Underscore (_)
        Underscores can be used within the class name to separate words or identifiers. For example, ZCL_MY_CLASS.

    Length
        The maximum length of an ABAP class name is 30 characters.

    Prefixing with Z or Y (for custom objects)
        Custom class names must begin with Z or Y to distinguish them from SAP standard classes.

Not Allowed in ABAP Class Names

    Special Characters
        Characters like $, %, &, #, @, etc., are not allowed.

    Spaces
        Class names cannot contain spaces.

    Starting with a Digit
        The name cannot begin with a number (e.g., 1CL_MYCLASS is invalid).

    Reserved Words
        Names that match reserved keywords in ABAP are not allowed.

    SAP Standard Namespace
        Names that do not start with Z or Y are reserved for SAP standard objects. Creating custom classes without these prefixes can lead to conflicts.

Naming Conventions

    General Structure:
    ZCL_ + descriptive name, e.g., ZCL_ORDER_MANAGEMENT.

    Purpose-Specific Prefixes:
        ZCL_ for classes
        ZIF_ for interfaces
        ZCX_ for exceptions

_____________SYNTAX OF ABAP______________
1.start with a keyword
2.end with a perios (.)
3.not case sensitive usually keywords caps and identifiers lower case or camel case
4.all data objects have static type
5. have built in db ...sql for queries and entity anipuoation language for modifications

___________EXAMPLES OF ABAP STATEMENTS____________
1.DECLARATIVE STATEMENTS
    used to declare a variable
eg:DATA name TYPE c LENGTH 10.        // keywords DATA, TYPE,LENGTH are in caps as they are keywords and the                                           rest are in lowecase as they are identifiers
    DATA text TYPE string.
2.EXECUTABLE STATEMENTS
    CONCATENATE 'Hello' name INTO text.

____________EXAMPLES OF ABAP EXPRESSIONS____________
 1.literal
    text ='Hello'.
2.variable
    text=name.
3.function
    text=replace( val='Hello world'
                sub='world'
                with='name'.)
4.conditional assignment
    text=COND#(WHEN text='' THEN Hello && name ELSE text).

__________________________COMMENTS  IN ABAP________________________
for commentinng aline u can include * in the first coloumn   
    *comment.....
for commenting in between we can use "
     text=name.  "comment.....
for commenting many lines  select those lines and ctrl+<

_______________DATA OBJECTS IN ABAP_____________
1.VARIABLES
    *its value can be changed any time
    *it has a  name
    *using the name it can be called any time 
2.CONSTANTS
    *its value is set by hardcoding
    *it has a name
    *can be called anywhere in the program
3.LITERALS
    *its value can  be set only one time
    *no name
    *cant access it again 

_______________DECLARATION OF VARIABLES_______________

DATA <variable name> TYPE <datatype> VALUE<starting value>
eg:
    DATA my_variable1 TYPE i.
    DATA my_variable1 TYPE string.
    DATA my_variable1 TYPE string VALUE='hello world'. 

======>DATA
    keyword data is used before the variable name 
    variable name  can be max 30 characters
    it can have digits alphabets or underscore
    can start with alphabet or underscore
======>TYPE
    TYPE keyword is followed by the datatype of the variable
    i for integer
    string
======>VALUE
    value is optional 

_____________EXAMPLE OF USING DATATYPE______________

======>STRING
CLASS zcl_data_types1 DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES if_oo_adt_classrun .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.



CLASS zcl_data_types1 IMPLEMENTATION.


  METHOD if_oo_adt_classrun~main.
  DATA x TYPE string.
  out->write( 'this variable is a string' ).
  ENDMETHOD.
ENDCLASS.

=======>INTEGER
  METHOD if_oo_adt_classrun~main.
    DATA x TYPE i.
    x = 42.
    out->write( |{ x }| ).
  ENDMETHOD.
=======>DATES
dates are usually written in yyyymmdd format .
*we can format the date into particular format using the predefined user format for date
*we can also extract the year moth and date from that particular date

  METHOD if_oo_adt_classrun~main.
    DATA birthday TYPE d.
    DATA year TYPE n LENGTH 4.
    DATA month TYPE n LENGTH 2.
    DATA day TYPE n LENGTH 2.
    DATA formatted_date TYPE string.

    birthday = '20120615'.

    formatted_date = |{ birthday DATE = USER }|.

    year = birthday+0(4).
    month = birthday+4(2).
    day = birthday+6(2).

    out->write( |{ formatted_date }| ).
    out->write( |Birthyear is: { year }| ).
    out->write( |Month is:{ month }| ).
    out->write( |Day is:{ day }| ).
  ENDMETHOD.


------->output


06/15/2012
Birthyear is: 2012
Month is:06
Day is:15

*usually indexing start from 0.
*year = birthday+0(4). //birthday + start index (number of                     characters to be extracted)
*month = birthday+4(2).// here indexing start from 4 so that 0,1,2,3 is the year and 4,5 give the month
*day = birthday+6(2). //here indexing start from 6 so that 6,7 gives the day

======>CHARACTER
*character dentoted by c we can also fix the length to set the maximum size
*character can have alphabets ,numbers or symbols

  METHOD if_oo_adt_classrun~main.
    DATA var TYPE c LENGTH 10.

    var = 'Ab3nb,$f'.

    out->write( |Variable is:{ var }| ).
  ENDMETHOD.
=======>NUMERIC TEXT

    *it can hold numerci values as a text
    *if we fix a length for them then it is padded with zeros to maintain that length
    
METHOD if_oo_adt_classrun~main.
    DATA var TYPE n LENGTH 10.

    var = '67854'.

    out->write( |Variable is:{ var }| ).
  ENDMETHOD.

------>OUTPUT
Variable is:0000067854

======>PACKED DECIMAL
 METHOD if_oo_adt_classrun~main.
    DATA var TYPE p LENGTH 8 DECIMALS 2.
    var = 1234783456789.
    out->write( |Variable is:{ var }| ).
  ENDMETHOD.

*length 8 means each byte can store two gits ...so total number of digits that can be stored is 2*length-1
=> 2 *8 -1=15...so 15 digits are possible and one positive or negative sign also
*Decimals 2 means theere will be two digits after the decimal places

________________CONSTANTS______________
*value cannot be changed
*use keyowrd CONSTANTS
*VALUE is mandatory

  CONSTANTS const1 TYPE string VALUE 'Hello'.
  CONSTANTS const1 TYPE i VALUE 1234.

________________LITERALS______________

1. Number Literals:

    Definition: These are integers (positive or negative) used directly in the code.
    Example: 123, -456, 7890.
    Data Type: By default, number literals are interpreted as data type I (Integer). If the number exceeds the size of I (e.g., too large), ABAP uses P (Packed Decimal) for larger values without decimals.
    Assignment Example:

    DATA num TYPE I.
    num = 123.  " Number literal

If the value exceeds the range of I:

DATA large_num TYPE p LENGTH 16 DECIMALS 0.
large_num = 1234567890123456.  " Packed decimal, for large numbers

2. Text Literals:

    Definition: These are character strings enclosed in single quotes.
    Example: 'Hello, world!', 'ABAP', '123'.
    Data Type: They are of type C (Character), and the length of the text is derived from the number of characters inside the quotes (trailing spaces are ignored).
    Assignment Example:

    DATA text TYPE C LENGTH 10.
    text = 'ABAP'.  " Text literal

In this example, the text 'ABAP' will be stored in the variable text, and the length of text would be 4 characters (the trailing blanks are ignored).
3. String Literals:

    Definition: These are strings enclosed in backticks (`).
    Example: `Hello, world!`, `ABAP`.
    Data Type: String literals are of type STRING. These are typically used for longer or dynamic text content.
    Assignment Example:

DATA str TYPE STRING.
str = `Hello, ABAP!`.  " String literal

____________LOCAL TYPES____________
Types is used to create custom datatypes which can be used again in different parts of the program.
    * we can give different names to the types
    * later on while defining a variable we can use that name

    TYPES my_type1 TYPE p LENGTH 3 DECIMALS 2.
    TYPES my_type2 TYPE i .*
    TYPES my_type3 TYPE string.
    TYPES my_type4 TYPE n length 10.

    DATA my_variable TYPE my_type1.
    my_variable = 23456.78.

    out->write(   my_variable ).

____________GLOBAL TYPES__________
    these datatypes are globally declared and have predefined length etc.
    it can be accessed anywher in the system
    DATA airport TYPE /dmo/airport_id VALUE 'FRA'.            //here /dmo/airport_id is the global type thats already declared

    out->write(   airport ).

_____________RESETTING VARIABLES_____________
*CLEAR can be used to reset the value of variables
*It will be initialised to zero

CLEAR my_var1.
____________INLINE DECLARATION____________
    *instead of explicitly declaring thevariable and then assign the value we can do this together by giving the variable name inn brackets 
    *remember no spaces are allowed in between the keyword data or between the bracket and variables

    
  METHOD if_oo_adt_classrun~main.
  DATA(my_var) ='Hello'.
  DATA(my_var1) = 123.
  out->write( my_var ).
  out->write( my_var1 ).
  ENDMETHOD.
------->output
Hello
123          

___________ARITHMETIC EXPRESSIONS___________

1.Addition(+)
2.Subtraction(-)
3.Multiplication(*)
4.Division(/)
5.DIV  - for whole number division
6.MOD  - for remainder after division
7.sqrt()    square root
8.ipow()    integer exponentiation

****order of precedence****

functions->multiplication/division->addition/subtraction

if equal PRECEDENCE then FROM LEFT->RIGHT
****there shhould be blank space between the operators otherwise syntax error
            
        METHOD if_oo_adt_classrun~main.
              TYPES type1 TYPE i.
              DATA result1 TYPE type1.
              DATA result2 TYPE type1.
              DATA result3 TYPE type1.
              DATA result4 TYPE type1.
              DATA result5 TYPE type1.
              DATA result6 TYPE type1.
              DATA result7 TYPE type1.
              DATA result8 TYPE type1.
              DATA result9 TYPE type1.
            
            
              result1 = 90 - 10.            "put space between the operands
              result2 = 90 + 10.
              result3 = 5 * 6.
              result4 = 50 / 2.
              result5 = 61 MOD 3.
              result6 = 40 DIV 2.
              result7 = sqrt( 49 ).
              result8 = ipow( base = 2 exp = 3 ).
              result9 = ( 5 * 5 - 5 ) / ( 1 + 4 ).
            
              out->write( result1 ).
              out->write( result2 ).
              out->write( result3 ).
              out->write( result4 ).
              out->write( result5 ).
              out->write( result6 ).
              out->write( result7 ).
              out->write( result8 ).
              out->write( result9 ).
            
              ENDMETHOD.
----->OUTPUT:

80           
100          
30           
25           
1            
20           
7            
8            
4            


______________FORMAT OPTIONS DATE _______________

      METHOD if_oo_adt_classrun~main.
      DATA date TYPE d VALUE '19870923'.
      out->write( |{ date }| ).    //when we give variable inside the curly bracket(embedded expression inside string) then it is considered as string
      out->write( |{ date DATE = ISO }| ).   //when we format it using the DATE =<date_format>  here ISO which is international standard and its in yyyy-mm-dd format
      out->write( |{ date DATE = USER }| ).
      ENDMETHOD.


------->OUTPUT
19870923
1987-09-23
09/23/1987


_____________FORMATTING NUMBER__________
      METHOD if_oo_adt_classrun~main.
      DATA my_number TYPE p LENGTH 3 DECIMALS 2 VALUE '-273.67'.
      out->write( |{ my_number }| ).
      out->write( |{ my_number NUMBER = USER }| ).
      out->write( |{ my_number STYLE = SCIENTIFIC }| ).
      out->write( |{ my_number SIGN = RIGHT }| ).
    
      ENDMETHOD.

----------->OUTPUT

-273.67
-273.67
-2.7367E+02
273.67-
______________&& OPERATOR_____________

      METHOD if_oo_adt_classrun~main.
      DATA result1 TYPE string.
      DATA result2 TYPE string.
      DATA part1 TYPE string VALUE 'Welcome'.
      DATA part2 TYPE string VALUE 'to'.
      DATA part3 TYPE string VALUE 'Eclipse'.
      result1 = part1 && part2 && part3.
      result2 = part1 && | | && part2 && | | && part3.   //WE HAVE TO LEAVE AN EMPTY SPACE IN BETWEEN THE STRING BRACKETS
    
      out->write( |{ result1 }| ).
      out->write( |{ result2 }| ).
      ENDMETHOD.

------>OUTPUT

WelcometoEclipse
Welcome to Eclipse


         METHOD if_oo_adt_classrun~main.
        
        * Declarations
        **********************************************************************
            TYPES t_amount TYPE  p LENGTH 8 DECIMALS 2.
        
            DATA amount   TYPE t_amount VALUE '353676767787.839'.
            DATA amount1  TYPE t_amount VALUE '1.20'.
            DATA amount2  TYPE t_amount VALUE '2.10'.
        
            out->write( |{ amount }| ).
            out->write( |{ amount1 }| ).
            out->write( |{ amount2 }| ).
        
            DATA(text) = 'Hello World'.
            DATA(text1) = | Total: { amount } INR |.
            DATA(string) = 'Hello World'.
            out->write( text ).
            out->write( text1 ).
            out->write( string ).
        
        
         ENDMETHOD.

------->OUTPUT

353676767787.84
1.20
2.10
Hello World
 Total: 353676767787.84 INR 
Hello World


_____________ADD TWO NUMBERS____________

          METHOD if_oo_adt_classrun~main.
          DATA number1 TYPE i.
          DATA number2 TYPE i.
          number1 = 3.
          number2 = -8.
        
          out->write( |{ number1 + number2 }| ).
          ENDMETHOD.

----->OUTPUT
-5

______________RATIO OF TWO NUMBERS_____________
      METHOD if_oo_adt_classrun~main.
      DATA number1 TYPE i VALUE 40.
      DATA number2 TYPE i VALUE 5.
      DATA(result) = number1 / number2.
      out->write( result ).
      ENDMETHOD.
----->OUTPUT
8

____________________CONDITIONAL EXPRESSIONS_______________

 1.IF ......ELSEIF....ELSE.....ENDIF.

          DATA num TYPE i VALUE 2.
          IF num = 1.
          out->write( num ).
          ELSEIF num = 2.
          out->write( |num is 2| ).
          ELSE.
          out->write( 'num is not 0' ).
          ENDIF.
          ENDMETHOD.
Here If condition and end if is mandatory ...else and else if are not mandatory
*if there is no else if then it wont check any other options
*if there is not else statement then one or no statement will be executed.
*ternary operator (.) is needed after every statement

    1.comparison operators
    2.logical operators
    3.sequence of evaluation
    4.special expressions

====>IS INITIAL(special expressions)

if the variable is set to the initial value then the statement is executed
                  METHOD if_oo_adt_classrun~main.
                  DATA num TYPE i.
                  num = 9.
                  IF num IS INITIAL.
                  out->write('num is initialised to 0' ).
                  ENDIF.
                  IF num IS NOT INITIAL.
                  out->write( 'num is not initialised to 0' ).
                  ENDIF.
                
                  DATA num1 TYPE n LENGTH 3.
                  num1 = 987.
                  IF num1 IS INITIAL.
                  out->write( |num1 is correctly initialised| ).
                  ELSE.
                  out->write( |num1 is not correctly initialised| ).
                  ENDIF.
                
                  ENDMETHOD.
2.CASE.......WHEN....WHEN OTHERS.....ENDCASE
                  DATA number TYPE i VALUE 8.
                  CASE number.
                  WHEN 1.
                  out->write( |number is 1| ).
                  WHEN 2.
                    out->write( |number is 2| ).
                  WHEN OTHERS.
                  out->write( |number is not any of the above| ).
                  ENDCASE.
                
                  ENDMETHOD.

____________________EXCEPTIONS___________________
errors encountered during the execution of ABAP program
Based on who raises the exception its called System exception and Application Exception

1. SYSTEM EXCEPTION
2.APPLICATION EXCEPTION

****EXAMPLES OF RUNTIME EXCEPTIONS
1.division by 0
2.string assigned to integer

___________HOW TO HANDLE THESE EXCEPTIONS______________

we have to handle these exceptions from the program itself using  TRY..CATCH...CATCH...ENDTRY

EXAMPLE 1(division by zero)

          METHOD if_oo_adt_classrun~main.
          DATA numerator TYPE i VALUE 6.
          DATA denominator TYPE i VALUE 2.
          DATA result TYPE i.
        
          TRY.
          result = numerator / denominator.
          out->write( result ).
          CATCH cx_sy_zerodivide.
            out->write( | not possible | ).
          ENDTRY.
          out->write( 'end of the demo' ).
          ENDMETHOD.

----->output
3            
end of the demo

EXAMPLE 2(Type mismatch )
            METHOD if_oo_adt_classrun~main.
              DATA result1 TYPE i.
              DATA str TYPE string VALUE 'ABC'.
            
              TRY.
              result1 = str.
              out->write( |result1| ).
              CATCH cx_sy_conversion_no_number.
              out->write( |string cannot be assigned to integer| ).
              ENDTRY.

-------->output
string cannot be assigned to integer

EXAMPLE 3( accessing a row which is not present in internal table)

         METHOD if_oo_adt_classrun~main.
          DATA table1 TYPE TABLE OF i.
          DATA index TYPE i VALUE 2.
          DATA result2 TYPE i.
          APPEND 10 TO table1.
        
          TRY.
          result2 = table1[ index ].
          out->write( result2 ).
          CATCH cx_sy_itab_line_not_found.
          out->write( |row does not exist in table | ).
        
          ENDTRY.

------>output

row does not exist in table 

________________________ITERATIONS__________________
used to execute something n number of times 
1. DO...........ENDDO

>>>>>>>>>> specified  number of iterations

DO <integer expression> TIMES.
  <statement>
ENDDO.

          METHOD if_oo_adt_classrun~main.
          DATA count TYPE i VALUE 5.
          DO count TIMES.
             out->write( 'HAI' ).
          ENDDO.
          ENDMETHOD.

>>>>>>>>>> Abort condiion in DO.....ENDDO
         DATA c_num TYPE i VALUE 3.
          DATA number TYPE i.
        
          number = c_num * c_num.
        
          DO.
          out->write( |{ sy-index }. Value of number : { number }| ).
          number = number - 1.
            IF number <= c_num.
              EXIT.
            ENDIF.
          ENDDO.

-------->output:

1. Value of number : 9
2. Value of number : 8
3. Value of number : 7
4. Value of number : 6
5. Value of number : 5
6. Value of number : 4

*sy-index gets the current iteration number

______________INTERNAL TABLES_________________
*internal tables store the data of the same type
*each data is stored as rows
*each row hold a value
*any number of data can be stored
*by default the table will be with no data or zero rows
*we can add data using APPEND

DATA tablename TYPE TABLE OF <rowtype>
APPEND 123 to table name

=======>TABLE TYPES
------->using TYPE OF statement
eg:DATA my_table TYPE TABLE OF i.
   APPEND 34 TO my_table.

or we can decare the type generallly

eg: TYPES table_type1 TYPE TABLE OF string.
    DATA table1 TYPE table_type1.

--------->GLOBAL TABLES
*they have a global scope rather than the scope of tables inside the block of execution or method or class.
*those tables present in ABAP dictionary

eg:DATA flights TYPE /DMO/T_FLIGHT.

________________ACCESSING DATA IN A TABLE USING LOOP__________

=======>EXPLICIT DECLARATION
              METHOD if_oo_adt_classrun~main.
              DATA table1 TYPE TABLE OF i.
              DATA numbers TYPE i.   //here we explicitly write to loop what
            
              APPEND 12 TO table1.
              APPEND 45 TO table1.
              APPEND 36 TO table1.
            
              LOOP AT table1 INTO numbers.
              out->write( numbers ).
              ENDLOOP.
              ENDMETHOD.

-------->OUTPUT
12           
45           
36   

=========>INLINE DECLARATION

              METHOD if_oo_adt_classrun~main.
              DATA table1 TYPE TABLE OF i.
            
              APPEND 12 TO table1.
              APPEND 45 TO table1.
              APPEND 36 TO table1.
            
              LOOP AT table1 INTO DATA(numbers).    //here we declare the loop element using DATA()
              out->write( numbers ).
              ENDLOOP.
              ENDMETHOD.

_________________PRINTING FIBONACCI USING INTERNAL TABLES_________________

              METHOD if_oo_adt_classrun~main.
              DATA table1 TYPE TABLE OF i.
              CONSTANTS max_count TYPE i VALUE 20.
            
              DO max_count TIMES.
              CASE sy-index.            //start with 1
                WHEN 1.
                  APPEND 1 TO table1.
                WHEN 2.
                  APPEND 2 TO table1.
                WHEN OTHERS.
                  APPEND table1[ sy-index - 1 ] + table1[ sy-index - 2 ] TO table1.
              ENDCASE.
              ENDDO.
            
              LOOP AT table1 INTO DATA(numbers).
                 out->write( numbers ).
              ENDLOOP.
              ENDMETHOD.

_________________________Storing the formatted data in another table of fibo series___________________________


->we already have a table table 1 which stres the fibonacci nuumbers 
->we create another table output which holds the data of type string to display the formatted output
->we also set a counter to give indexing in the output
->during the looping through each of the numbers in fibo series table1 we write the statement to append the table output also
->now the table output has all the required data with correct formatting
->now loop through the table output to see the result
            METHOD if_oo_adt_classrun~main.
              DATA table1 TYPE TABLE OF i.
              CONSTANTS max_count TYPE i VALUE 20.
            
              DO max_count TIMES.
              CASE sy-index.
                WHEN 1.
                  APPEND 1 TO table1.
                WHEN 2.
                  APPEND 2 TO table1.
                WHEN OTHERS.
                  APPEND table1[ sy-index - 1 ] + table1[ sy-index - 2 ] TO table1.
              ENDCASE.
              ENDDO.
            
              DATA output TYPE TABLE OF string.
            
              DATA(counter) = 0.
              LOOP AT table1 INTO DATA(numbers).
                 counter = counter + 1.
                 APPEND |{ counter WIDTH = 4 } : { numbers WIDTH = 10 ALIGN = LEFT }| TO output.
              ENDLOOP.
            
              LOOP AT output INTO DATA(num).
                 out->write( num ).
              ENDLOOP.
            
              ENDMETHOD.

---------->OUTPUT


1    : 1         
2    : 2         
3    : 3         
4    : 5         
5    : 8         
6    : 13        
7    : 21        
8    : 34        
9    : 55        
10   : 89        
11   : 144       
12   : 233       
13   : 377       
14   : 610       
15   : 987       
16   : 1597      
17   : 2584      
18   : 4181      
19   : 6765      
20   : 10946     


______________________CLASSES_________________

==========>GLOBAL CLASSES
    Stored centrally in the ABAP Repository.
    Can be reused across different programs.
*its the class we crate an write program it 
*it has both definition and implementation part

===========>LOCAL CLASS
*accessed within the program only
*to create local class inside global class we can go to windows-> editor->type lcl and then ctrl+space ->in the code remove the private class from the definition
*now we can specify and write both instance and static methods, data ,etc inside the definitions

*this is how local types will look like
            *"* use this source file for the definition and implementation of
            *"* local helper classes, interface definitions and type
            *"* declarations
            class lcl_ definition .
            
              public section.
                DATA carrier_id TYPE /DMO/CARRIER_ID.        //instance attribute
                DATA connection_id TYPE /DMO/CONNECTION_ID.      //instance attribute
                CLASS-DATA conn_counter TYPE i.      //static attribute
              protected section.
              private section.
            
            endclass.
            
            class lcl_ implementation.
            
            endclass.


------->if we create these instance and static attributes inside the local class then we can access them inside the global class of this.

----->In the global class write like this to access them

              METHOD if_oo_adt_classrun~main.
              lcl_=>conn_counter = 123.
              DATA connection TYPE REF TO lcl_.
              connection = NEW #(   ).
              connection->carrier_id = 23.
            
              out->write( lcl_=>conn_counter ).
            
              out->write( connection->carrier_id ).
            
              ENDMETHOD.

---------->OUTPUT

123          
23

___________________DEFINING AND CALLING METHODS_________________
in the above case we saw how can we define an attribute and call them. Similarly we can create methods in the local  class and call themin the global class.Methods are like functions.We can define the methods in the definitions section.

CLASS <classname> DEFINITION
  <public or privateor protected section>
        METHODS <methodname>
            IMPORTING <input1> TYPE <>
                      <input2> TYPE <> DEFAULT <val>
            EXPORTING <output1> TYPE <>
                        ....
            CHANGING <inout1> TYPE <type>
                    ...
            RETURNING VALUE (<result>) TYPE <type>
            RAISING <exception1>
                     ...
ENDCLASS.

----PARAMETERS AND EXCEPTIONS-----
while writing the methods we can use parameters and exceptions
1. IMPORTING PARAMETERS
*they are those values passed from the caller of the method
*values are accepted
*any number of params possible
*can be made optional
*cannot modify

2.EXPORTING PARAMS
*results that are returned by a method
*all params are optional

3.CHANGING PARAMS
*they arealso the params received from the caller but acan be chnaged.(importing para cannot be changed)
*any no.of params possible
*can be made optional
*can modiify

4.RETURNING PARAMS
*they are like exporting params
*used when we have only a single value to export
*can be exported using RETURNING VALUE(<param>)

5.RAISING
*used to raise all possible exceptions

--------IMPLEMENTATION of METHODS in LOCAL CLASS-------
*suppose the attribute name specified in definition and the refernce variable in the global class has the same value then we have to use the self reference operator(->) to uniquely identify the attribute name.

*if both name sre different then no problem

--------USAGE OF METHODS--------
sometimes we write the attriibutes in the local class and the method definitoon and implmentation also in the local class. WE dont actually awnt to expose the actuall logic behind a method to other. Its a way of encapsulation.So we just call the method in the global cass and assign the value there.

----local class


            class lcl_ definition.
            
              public section.
            
                DATA carrier_id TYPE /DMO/CARRIER_ID.
                DATA connection_id TYPE /DMO/CONNECTION_ID.
                CLASS-DATA conn_counter TYPE i.
            
                 METHODS set_attributes
                    IMPORTING
                    i_carrier_id TYPE /dmo/carrier_id OPTIONAL
                    i_connection_id TYPE /dmo/connection_id.
                 METHODS get_attributes
                    EXPORTING
                    e_carrier_id TYPE /DMO/CARRIER_ID
                    e_connection_id TYPE /dmo/connection_id.
            
            
              protected section.
              private section.
            
            
            endclass.
            
            class lcl_ implementation.
            
            METHOD set_attributes.
            
              carrier_id = i_carrier_id.
              connection_id = i_connection_id.
            ENDMETHOD.
            
            METHOD get_attributes.
              e_carrier_id = carrier_id.
              e_connection_id = connection_id.
            ENDMETHOD.
            
            
            endclass.
---------global class

            CLASS zcl_34_local_class7 DEFINITION
              PUBLIC
              FINAL
              CREATE PUBLIC .
            
              PUBLIC SECTION.
            
                INTERFACES if_oo_adt_classrun .
              PROTECTED SECTION.
              PRIVATE SECTION.
            ENDCLASS.
            
            
            
            CLASS zcl_34_local_class7 IMPLEMENTATION.
                METHOD if_oo_adt_classrun~main.
                DATA connection TYPE REF TO lcl_.
            
                   connection = NEW #( ).
                   DATA: carrier_id TYPE /DMO/CARRIER_ID,
                      connection_id TYPE /DMO/CONNECTION_ID.
                   connection->set_attributes(
                      EXPORTING
                         i_carrier_id = 'SA'
                         i_connection_id = '56').
                   connection->get_attributes(
                      IMPORTING
                         e_carrier_id = carrier_id
                         e_connection_id = connection_id ).
            
            
                   out->write( connection ).
            
                ENDMETHOD.
            ENDCLASS.

---------OUTPUT

->                            
LCL_                                       
CARRIER_ID    CONNECTION_ID    CONN_COUNTER
SA            0056             0           

**if  we give those attributes in the private section then we cant log them in the console.

--------->To raise exceptions while using ivalid values for the attributes

use raising..make necessary modifications in both local types and global class

----LOCAL CLASS
            
            class lcl_ definition.
            
              public section.
            
                DATA carrier_id TYPE /DMO/CARRIER_ID.
                DATA connection_id TYPE /DMO/CONNECTION_ID.
                CLASS-DATA conn_counter TYPE i.
            
                 METHODS set_attributes
                    IMPORTING
                    i_carrier_id TYPE /dmo/carrier_id OPTIONAL
                    i_connection_id TYPE /dmo/connection_id
                    RAISING
                      cx_abap_invalid_value.
                 METHODS get_attributes
                    EXPORTING
                    e_carrier_id TYPE /DMO/CARRIER_ID
                    e_connection_id TYPE /dmo/connection_id.
            
            
              protected section.
              private section.
            
            
            endclass.
            
            class lcl_ implementation.
            
            METHOD set_attributes.
                IF i_carrier_id IS INITIAL OR i_connection_id IS INITIAL.
                  RAISE EXCEPTION TYPE cx_abap_invalid_value.
                ENDIF.
              carrier_id = i_carrier_id.
              connection_id = i_connection_id.
            ENDMETHOD.
            
            METHOD get_attributes.
              e_carrier_id = carrier_id.
              e_connection_id = connection_id.
            ENDMETHOD.
            
            
            endclass.

----->GLOBAL CLASS
            CLASS zcl_34_local_class7 DEFINITION
              PUBLIC
              FINAL
              CREATE PUBLIC .
            
              PUBLIC SECTION.
            
                INTERFACES if_oo_adt_classrun .
              PROTECTED SECTION.
              PRIVATE SECTION.
            ENDCLASS.
            
            
            
            CLASS zcl_34_local_class7 IMPLEMENTATION.
                METHOD if_oo_adt_classrun~main.
                DATA connection TYPE REF TO lcl_.
            
                   connection = NEW #( ).
                   DATA: carrier_id TYPE /DMO/CARRIER_ID,
                      connection_id TYPE /DMO/CONNECTION_ID.
                   TRY.
                   connection->set_attributes(
                      EXPORTING
                         i_carrier_id = '0'
                         i_connection_id = '0').
                   CATCH cx_abap_invalid_value.
                   out->write( 'method call failed' ).
                   ENDTRY.
                   connection->get_attributes(
                      IMPORTING
                         e_carrier_id = carrier_id
                         e_connection_id = connection_id ).
            
                   out->write( connection ).
            
                ENDMETHOD.
            ENDCLASS.

____________________USING ENCAPSULATION TO ENSURE CONSISTENCY_____________________
Encapsulationmeansto hide the implementation level details..
*we restrict the access of data or attrinbutes outside the class.
*after using this we cannot directly set the values.Insted we have to use some methods to set them.


to write local class type lcl then ctrl+space

            class lcl_ definition .
                    
              public section.
                 CLASS-DATA <public-attribute> TYPE <type>.
                 CLASS-DATA <readonly_attribute> TYPE <type> READ-ONLY.
                 
              protected section.
              private section.
              CLASS-DATA <private_attribute> TYPE <type>.
              
            endclass. 

*There are two ways to restrict the access to the attributes.
*one is to keep it in public section and make it read only so that it can be only read outside the class.
*or keep it in private or protected section so that they cannot be read or written outside the class.


